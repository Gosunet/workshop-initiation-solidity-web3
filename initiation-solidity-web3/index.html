
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Initiation solidity and Web3.0</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/claat-public/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid="Google Analytics ID"
                  id="initiation-solidity-web3"
                  title="Initiation solidity and Web3.0"
                  environment="web"
                  feedback-link="https://github.com/Gosunet/workshop-initiation-solidity-web3">
    
      <google-codelab-step label="Introduction" duration="5">
        <p>Welcome to this initiation Solidity and Web3! Let&#39;s learn how a Smart Contract contract works! ‚õµÔ∏è</p>
<p>We think those technologies are empowering, and open a brand new world of possibilities of what we can achieve as developers. It also brings more power into the hands of the user.</p>
<p>We&#39;ve made this project to have a better understanding of the NFT trend, and also to get our hands dirty.</p>
<p>Now you will too üòú</p>
<p>During this workshop you will:</p>
<ul>
<li>create your first Solidity smart contract</li>
<li>test our contract</li>
<li>deploy it on a real blockchain</li>
<li>integrate and interact with it in a small react application using web3.js</li>
</ul>
<p>To make this workshop more fun we will use a <a href="https://pimpmyduck.zenika.com/" target="_blank">small site made by Zenika</a> that allows us to customize a duck ü¶Ü .</p>
<p>What we want to do here is to create an NFT based on our custom duck! That will make us explore all the things we list above. üôå</p>
<p>Are you ready? Let&#39;s go! üöÄ</p>


      </google-codelab-step>
    
      <google-codelab-step label="Init your project üî®" duration="5">
        <p>If you have not done it yet, you can start by cloning this repo</p>
<pre><code language="language-sh" class="language-sh">git clone https://github.com/Gosunet/workshop-initiation-solidity-web3.git
</code></pre>
<p>If we take a look at the structure, we can notice it&#39;s a monorepo using yarn workspaces.</p>
<p>At the root, you can see a folder name <code>packages</code>. In this folder, we have separated packages.</p>
<p>We will focus on two packages today: <code>app</code> and <code>hardhat</code>.</p>
<p>The first contains our frontend, and the second will contains our contract.</p>
<p>Now we&#39;ve seen that, let&#39;s start building! üöÄ</p>
<h2 is-upgraded>Setup Hardhat</h2>
<p><a href="https://hardhat.org/hardhat-runner/docs/getting-started#quick-start" target="_blank">Hardhat</a> is a framework that will help us to:</p>
<ul>
<li>compile our smart contract</li>
<li>test our smart contract</li>
<li>deploy our smart contract</li>
</ul>
<p>If you feel adventurous you can alternatively use <a href="https://trufflesuite.com/docs/" target="_blank">Truffle</a> or <a href="https://github.com/foundry-rs/foundry" target="_blank">Fundry</a>. Both are pretty similar to Hardhat in terms of features.</p>
<p>Because installing hardhat in a monorepo is a little bit tricky, we setup dependencies for you.</p>
<p>You can still take a look at the dependencies listed in <code>packages/hardhat/package.json</code>.</p>
<p>Now is the time to init hardhat in your <code>packages/hardhat</code> folder</p>
<pre><code language="language-sh" class="language-sh">cd packages/hardhat
yarn install
yarn hardhat
</code></pre>
<p>üõ† If you don&#39;t have yarn installed you can install it globally like that</p>
<pre><code language="language-sh" class="language-sh">npm install --global yarn
</code></pre>
<p>Choose to create a new Javascript project, then accept the following step.</p>
<p>This will create folders :</p>
<ul>
<li><code>contracts</code> : folder for our solidity files,</li>
<li><code>scripts</code> : a directory that contains scripts to handle deployment, run, ...</li>
<li><code>test</code>: unit test sources,</li>
<li><code>hardhat-config.js</code> : config file for Hardhat</li>
</ul>
<p>Finally, run <code>yarn hardhat node</code> and this should print out a bunch of accounts.</p>
<p>Hardhat will generate some files for you, to make sure everything is working, run:</p>
<pre><code language="language-sh" class="language-sh"> yarn hardhat compile
</code></pre>
<p>Then run:</p>
<pre><code language="language-sh" class="language-sh"> yarn hardhat test
</code></pre>
<p>You should see a bunch of tests succeeded üéâ</p>
<p>You can now delete <code>Lock.js</code> under test, deploy.js under scripts and <code>Lock.sol</code> under contracts. (not the folder!)</p>


      </google-codelab-step>
    
      <google-codelab-step label="Write your first smart contract üÜï" duration="20">
        <p>Now that we have set up Hardhat let&#39;s create our first smart contract!</p>
<p>You will write code in Solidity. If you don&#39;t know it (and we guess that&#39;s why you are here üòú), don&#39;t panic.</p>
<p>The language is influenced by C++, Python and JavaScript.</p>
<p>Solidity is statically typed, supports inheritance, libraries and complex user-defined types among other features.</p>
<p>You can find the doc <a href="https://docs.soliditylang.org/en/v0.8.17/" target="_blank">here</a> if you want to get an overview.</p>
<p>Let&#39;s create a new file <code>MyEpicSmartContract.sol</code> under <code>contracts</code> folder.<br> Be careful file structure is important!</p>
<p>Copy this into your newly created file</p>
<pre><code language="language-javascript" class="language-javascript">// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.17;

import &#34;hardhat/console.sol&#34;;

contract MyEpicSmartContract {
    constructor() {
        console.log(&#34;Hello World !&#34;);
    }
}
</code></pre>
<p>‚ÑπÔ∏è If you use visual code you can install the <a href="https://marketplace.visualstudio.com/items?itemName=JuanBlanco.solidity&utm_source=buildspace.so&utm_medium=buildspace_project" target="_blank">solidity extension</a> for syntax highlighting.</p>
<p>Congratulation you have officially written your first smart contract ü•≥<br> Easy no?</p>
<p>Let&#39;s explain it a bit.</p>
<pre><code language="language-javascript" class="language-javascript">// SPDX-License-Identifier: UNLICENSED
// ‚¨ÜÔ∏è  Necessary definition of the licence, per file

pragma solidity ^0.8.17;
// ‚¨ÜÔ∏è  define the solidity version we use.

import &#34;hardhat/console.sol&#34;;
// ‚¨ÜÔ∏è  Module imports 

// ‚¨áÔ∏è  We define our contract with the `contract` keyword. It&#39;s kind of `class` equivalent.
contract MyEpicSmartContract {

    // ‚¨áÔ∏è  If you know OOP, you&#39;re familiar with that üòù
    constructor() {
        console.log(&#34;Hello World !&#34;);
    }
}
</code></pre>
<p>The next step is to compile our smart contract, to do so run <code>yarn hardhat compile</code>.</p>
<p>Now it&#39;s our turn to work!</p>
<p>Let&#39;s create a small function to set an attribute <code>name</code> into our smart contract. First, you will need to create a name attribute in your smart contract</p>
<pre><code language="language-javascript" class="language-javascript">contract MyEpicSmartContract {

    string name;
    
    ...
</code></pre>
<p>Then you can create your fonction</p>
<pre><code language="language-javscript" class="language-javscript">function setName(string newName) {
  name = x;
}
</code></pre>
<p>Try to compile now!<br> üí• You should get an error like that : <code>SyntaxError: No visibility specified. Did you intend to add "public"?</code></p>
<p>In solidity, like in some other language, you need to set the visibility of your function.<br> Here we want this method to be callable from outside our contract so we need to add the <code>public</code> keyword like that</p>
<pre><code language="language-javascript" class="language-javascript">function setName(string x) public {
        name = x;
}
</code></pre>
<p><a href="https://solidity-by-example.org/visibility/" target="_blank">Here</a> is the visibility doc for Solidity if you are curious about other visibilities.</p>
<p>Head back to your terminal, you should also see this error <code>TypeError: Data location must be "memory" or "calldata" for parameter in function, but none was given.</code></p>
<p>The solidity compiler tells you here that you need to specify the <a href="https://solidity-by-example.org/data-locations/" target="_blank">storage location</a> of your input name. You should use <code>calldata</code>, it&#39;s a special data location that contains function arguments, and the advantage is that it cost nothing. <code>memory</code> could work too but <code>calldata</code> is designed for input parameters so let&#39;s use this.</p>
<p>Then another function <code>sayHello</code> will simply use the name you just set to do a console log like that <code>console.log("Hello World !");</code></p>
<p>This should be good for the <code>setName</code> method, go ahead and create the <code>sayHello</code> method now.</p>
<p>Again, here is a <a href="https://docs.soliditylang.org/en/v0.8.12/introduction-to-smart-contracts.html" target="_blank">link</a> to help you with that.</p>
<p>Let&#39;s see how to run it!</p>
<h2 is-upgraded>A script to run our contract</h2>
<p>Hardhat allows us to deploy our smart contract in a local blockchain, and it allows us to do it very easily.</p>
<p>We just have to write a small script to do that, so let&#39;s go!</p>
<p>Create a file <code>run.mjs</code> under <code>scripts</code>.</p>
<pre><code language="language-javascript" class="language-javascript">const contractFactory = await hre.ethers.getContractFactory(&#39;MyEpicSmartContract&#39;);
const contract = await contractFactory.deploy();
await contract.deployed();
console.log(&#34;Contract deployed to:&#34;, contract.address);

// Call the function.
let txn = await contract.setName(&#34;Fellow Codeur (en seine)&#34;)
// Wait for it to be finished.
await txn.wait()
// Call another function
await contract.sayHello()
</code></pre>
<p>To call your script just run <code>yarn hardhat run scripts/run.mjs</code>.</p>
<p>You should get something like that!</p>
<pre><code language="language-bash" class="language-bash">Hello World !
Contract deployed to: 0x5FbDB2315678afecb367f032d93F642f64180aa3
Hello Fellow Codeur (en seine)
</code></pre>
<p><code>0x5FbDB2315678afecb367f032d93F642f64180aa3</code> here is the contract address in our local blockchain where the contract was deployed.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Create a contract that mints NFTs ü¶Ü" duration="20">
        <p>It&#39;s all fun and stuff but our contract is not doing anything useful for our use case.</p>
<p>Let&#39;s change that! What we want is a contract that enables us to <code>mint</code> an NFT. Mint just means to create our NFT in the blockchain.</p>
<p>But what&#39;s an NFT? On the EVM-compatible blockchain, an NFT is &#34;just&#34; an [ERC-721 <a href="https://ethereum.org/en/developers/docs/standards/tokens/erc-721/" target="_blank">token</a>, which means that our smart contract should implement the ERC-721 interface!</p>
<p>That&#39;s a lot of work. Fortunately for us in Solidity, we can use inheritance and there are open-source contracts available that we can inherit from to do that! <a href="https://github.com/OpenZeppelin" target="_blank">OpenZeppelin</a> is probably the most know for that, is popular, used by a lot of people, and secure (at least it has been audited strongly and used in the real world without flaws).</p>
<p>We first need to add the OpenZeppelin dependency. In the <code>harhdat</code> folder run:</p>
<pre><code language="language-bash" class="language-bash">yarn add @openzeppelin/contracts
</code></pre>
<p>Then import them in our contract like that:</p>
<pre><code language="language-javascript" class="language-javascript">import &#34;@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol&#34;;
import &#34;@openzeppelin/contracts/utils/Counters.sol&#34;;
</code></pre>
<p>As you can see we also import <code>Counters.sol</code>, this will help us to generate our NFT id.</p>
<p>Now that we have imported the contract <code>ERC721URIStorage</code> what we need to do now is to make our contract inherit from it.</p>
<p>To do that it&#39;s pretty simple!</p>
<pre><code language="language-javascript" class="language-javascript">// We inherit the contract we imported. This means we&#39;ll have access
// to the inherited contract&#39;s methods.
contract MyEpicSmartContract is ERC721URIStorage {

  // We need to pass the name of our NFTs token and it&#39;s symbol.
  constructor() ERC721 (&#34;CryptoDuck&#34;, &#34;DUCK&#34;) {
    console.log(&#34;This is my NFT contract. Woah!&#34;);
  }
</code></pre>
<p>You will see that here we need to call the <code>ERC721</code> contract constructor with two strings, one for the name of our NFT token, and the other one for the symbol of our collection.</p>
<p>Feel free to name it as you want üòâ</p>
<p>Now we can use the <code>ERC721</code> contract method!<br> Let&#39;s create the method that we will call to create our NFT that will represent our custom duck.<br> We don&#39;t want to store the whole duck SVG in our contract because storage in the blockchain costs money üí∞ so we will only store the URL to access our duck SVG.</p>
<p>‚ÑπÔ∏è Remember that data in the blockchain are immutable, this is why our URL must be accessible FOREVER! That&#39;s why it&#39;s strongly recommended to store our image in a decentralized store file system like IPFS.</p>
<pre><code language="language-javascript" class="language-javascript">function makeAnEpicNFT(string memory srcTokenUri) public { 

}
</code></pre>
<p>Each of our NFTs will need a unique ID to do that we will use the <code>Counters.sol</code> we have imported.</p>
<p>Add this to your contract:</p>
<pre><code language="language-javascript" class="language-javascript">using Counters for Counters.Counter;
Counters.Counter private _tokenIds;
</code></pre>
<p>Let&#39;s code our contract to mint an NFT now!</p>
<p>First, we want to get the current ID for your new NFT.</p>
<pre><code language="language-javascript" class="language-javascript">uint256 newItemId = _tokenIds.current();
</code></pre>
<p>Then we will mint our NFT calling the method from the OpenZeppelin contract (all internal methods are prefixed with an underscore)</p>
<pre><code language="language-javascript" class="language-javascript">_safeMint(msg.sender, newItemId);
</code></pre>
<p>Notice <code>msg.sender</code> here, it&#39;s a magic solidity variable that holds the address of the wallet that calls this method.</p>
<p>We want our NFT to have an image, to do that we will create a <code>payload</code> that respects some convention used to parse NFT, doing that our NFT will be readable in a marketplace like <a href="https://opensea.io/" target="_blank">OpenSea</a>. We also want our payload to be as tiny as possible, that&#39;s why we will encode it in base64.</p>
<pre><code language="language-javascript" class="language-javascript">// Get all the JSON metadata in place and base64 encode it.
string memory json = Base64.encode(
    string(
        abi.encodePacked(
            &#39;{&#34;name&#34;: &#34;Crypto Duck&#34;, &#34;description&#34;: &#34;A magnificent crypto duck.&#34;, &#34;image&#34;: &#34;&#39;, srcTokenUri, &#39;&#34;}&#39;
        )
    )
);

// Just like before, we prepend data:application/json;base64, to our data.
string memory finalTokenUri = string(
    abi.encodePacked(&#34;data:application/json;base64,&#34;, json)
);
</code></pre>
<p>Feel free again to change the name or description of our Duck. Maybe you can have a dynamic name and a description? Use a name set in the frontend?</p>
<p>To be able to use the <code>Base64.encode</code> we need to add the Base64 library to our project.<br> Create a <code>libraries</code> package under <code>contracts</code> and create a file <code>Base64.sol</code> in it. You can find the content of this file <a href="https://github.com/BlockChainCaffe/Base64.sol/blob/main/contracts/base64.sol" target="_blank">here</a>.<br> After that import the library into our contract file.</p>
<pre><code language="language-javascript" class="language-javascript">import { Base64 } from &#34;./libraries/Base64.sol&#34;;
</code></pre>
<p>Finally, we need to set the data to the NFT</p>
<pre><code language="language-javascript" class="language-javascript">// Set the NFTs data.
_setTokenURI(newItemId, finalTokenUri);

console.log(&#34;An NFT w/ ID %s has been minted to %s&#34;, newItemId, msg.sender);
</code></pre>
<p>and increment the counter.</p>
<pre><code language="language-javascript" class="language-javascript">// Increment the counter for when the next NFT is minted.
_tokenIds.increment();
</code></pre>
<p>One thing that we can do is to emit an Event, the front will be able to listen to that Event and show some stuff to the user.</p>
<p>To do that declare a new Event in our contract</p>
<pre><code language="language-javascript" class="language-javascript">event NewNFTMinted(address sender, uint256 tokenId);
</code></pre>
<p>and emit it at the end of your <code>makeAnEpicNFT</code> method.</p>
<pre><code language="language-javascript" class="language-javascript">emit NewNFTMinted(msg.sender, newItemId);
</code></pre>
<p>At the end you should get something like that:</p>
<pre><code language="language-javascript" class="language-javascript">function makeAnEpicNFT(string memory srcTokenUri) public {
    // Get the current tokenId, this starts at 0.
    uint256 newItemId = _tokenIds.current();

     // Actually mint the NFT to the sender using msg.sender.
    _safeMint(msg.sender, newItemId);

    // Get all the JSON metadata in place and base64 encode it.
    string memory json = Base64.encode(
        string(
            abi.encodePacked(
                &#39;{&#34;name&#34;: &#34;Crypto Duck&#34;, &#34;description&#34;: &#34;A magnificent crypto duck.&#34;, &#34;image&#34;: &#34;&#39;, srcTokenUri, &#39;&#34;}&#39;
            )
        )
    );

    // Just like before, we prepend data:application/json;base64, to our data.
    string memory finalTokenUri = string(
        abi.encodePacked(&#34;data:application/json;base64,&#34;, json)
    );

    // Set the NFTs data.
    _setTokenURI(newItemId, finalTokenUri);

    console.log(&#34;An NFT w/ ID %s has been minted to %s&#34;, newItemId, msg.sender);

    // Increment the counter for when the next NFT is minted.
    _tokenIds.increment();

    emit NewNFTMinted(msg.sender, newItemId);
  }
</code></pre>
<p>That&#39;s cool and stuff but how can I test my code? Let&#39;s see that in the next chapter!</p>


      </google-codelab-step>
    
      <google-codelab-step label="Test it!" duration="20">
        <p>To test our smart contract we can update the <code>run.mjs</code> script to create our contract then call our new method <code>makeAnEpicNft</code>.</p>
<pre><code language="language-javascript" class="language-javascript">const nftContractFactory = await hre.ethers.getContractFactory(&#39;MyEpicSmartContract&#39;);
const nftContract = await nftContractFactory.deploy();
await nftContract.deployed();
console.log(&#34;Contract deployed to:&#34;, nftContract.address);

const svg = &#34;https://theduckgallery.zenika.com/ducks/jeanphibaconnais.png&#34;

// Call the function.
let txn = await nftContract.makeAnEpicNFT(svg)
// Wait for it to be mined.
await txn.wait()

// Mint another NFT for fun.
txn = await nftContract.makeAnEpicNFT(svg)
// Wait for it to be mined.
await txn.wait()
</code></pre>
<p>Here we used a png that is not stored in decentralized storage, but it&#39;s just for the test so it&#39;s not a problem, you can use any png.</p>
<p>Is it working? üéâ</p>
<p>That&#39;s nice but I think we can have better a test, can we unit-test our contract? YES, we can!</p>
<p>Let&#39;s create a <code>MySmartContractSolTest.js</code> file under the package <code>test</code></p>
<p>We can test that we emit our <code>NewNFTMinted</code> event. It&#39;s pretty much the same code that the <code>run.mjs</code> with some tests at the end.</p>
<p>Here is the code:</p>
<pre><code language="language-javascript" class="language-javascript">const { expect } = require(&#39;chai&#39;)

describe(&#39;MyEpicSmartContract contract&#39;, function () {
  it(&#39;Should emit NewNFTMinted&#39;, async function () {
    const [owner] = await ethers.getSigners()

    const nftContractFactory = await hre.ethers.getContractFactory(
      &#39;MyEpicSmartContract&#39;,
    )
    const nftContract = await nftContractFactory.deploy()
    await nftContract.deployed()
    console.log(&#39;Contract deployed to:&#39;, nftContract.address)

    const svg = &#39;https://theduckgallery.zenika.com/ducks/jeanphibaconnais.png&#39;

    await expect(nftContract.makeAnEpicNFT(svg))
      .to.emit(nftContract, &#39;NewNFTMinted&#39;)
      .withArgs(owner.address, 0) // first item
  })
})
</code></pre>
<p>We basically:</p>
<ul>
<li><code>deploy</code> the contract on Hardhat test chain</li>
<li>call the method <code>makeAnEpicNFT</code></li>
<li>and expect an event to be fire, using chai <code>expect</code></li>
</ul>
<p>To run it:</p>
<pre><code language="language-javascript" class="language-javascript">yarn hardhat test
</code></pre>
<p>Awesome we now have our smart contract tested üòé</p>


      </google-codelab-step>
    
      <google-codelab-step label="Deploy your smart contract üöÄ" duration="20">
        <p>Now that we have a working smart contract we want to deploy it on a real blockchain! So let&#39;s go üöÄ</p>
<h2 is-upgraded>Get a Wallet! And some ETH üí∞</h2>
<p>To deploy our smart contract we will need some Ethereum. Don&#39;t worry we will use the Goerli testnet of Ethereum so this will not cost us a penny!</p>
<p>So if you don&#39;t already have a wallet, download the <a href="https://metamask.io/download/" target="_blank">metamask extension</a>.</p>
<p>You will be guided on the setup phase by Metamask. When this part is done, switch to <code>Goerly network</code>, you should be on the Ethereum mainnet at first. If you don&#39;t see the <code>Goerly network</code> click on &#34;Show/hide testnet&#34;.</p>
<p>Once it&#39;s done you will see that you have 0 GoerliETH üò¢</p>
<p>So in order to get some GoerliETH you will have to request some in a faucet.</p>
<p>This one should work <a href="https://goerlifaucet.com/" target="_blank">https://goerlifaucet.com/</a>, you gonna need to create an Alchemy account though but we will need one right after so do create one and request our GoerliETH. To request your eth just copy and paste in the input our public key address from metamask (the one that looks like 0xf20...4D8 when you open it).</p>
<p>If you got some eth let&#39;s go to the next part üî•</p>
<h2 is-upgraded>Deploy</h2>
<p>Deploying our contract is pretty much like running it with the <code>run.mjs</code> script thanks to Hardhat.</p>
<p>So let&#39;s create a new script <code>deploy.mjs</code>:</p>
<pre><code language="language-javascript" class="language-javascript">const nftContractFactory = await hre.ethers.getContractFactory(&#39;MyEpicSmartContract&#39;);
const nftContract = await nftContractFactory.deploy();
await nftContract.deployed();
console.log(&#34;Contract deployed to:&#34;, nftContract.address);

const svg = &#39;https://theduckgallery.zenika.com/ducks/jeanphibaconnais.png&#39;

// Call the function.
let txn = await nftContract.makeAnEpicNFT(svg)
// Wait for it to be mined.
await txn.wait()
console.log(&#34;Minted NFT #1&#34;)
</code></pre>
<p>Now we have some setup to do.</p>
<p>First, you need to update your <code>hardhat.config</code> file. We need to add a new network, here Goerly, add this in the <code>module.export</code>:</p>
<pre><code language="language-javscript" class="language-javscript">networks: {
    goerli: {
      url: process.env.STAGING_ALCHEMY_KEY_URL,
      accounts: [process.env.PRIVATE_KEY],
    },
  },
</code></pre>
<p>Each time you want to deploy to a specific network you will need to add it like that in our Hardhat config. Pretty easy no?<br> You can deploy to every EVM-compatible blockchain like that, even a blockchain like Avalanche üòâ</p>
<p>You have surely noticed the <code>process.env.STAGING_ALCHEMY_KEY_URL</code> and <code>process.env.PRIVATE_KEY</code> values.</p>
<p>Add the <code>PRIVATE_KEY</code> value in a <code>.env</code> file, to get the value of our private key, go to metamask, click on the 3 dots next to our account, go to detail then click on &#34;export private key&#34;.<br> ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è You should never share this key with anyone! Otherwise, some bad-intentioned people can still our account, and all that is within it!</p>
<p>To get the <code>STAGING_ALCHEMY_KEY_URL</code> you need to log in to <a href="https://dashboard.alchemy.com/" target="_blank">Alchemy</a> and then create a new ‚Äòapp&#39; with the create app button. You will be asked to choose a name, a description and a chain, do as you like for the name and description and choose the Ethereum chain with Goerli network, you will get an HTTPS URL, this is our <code>STAGING_ALCHEMY_KEY_URL</code> that you need to add in your <code>.env</code> file.<br> The alchemy app will act as a node to the Ethereum Goerli network to interact with the blockchain.</p>
<p>Now that you set all the variables we need to add the <code>dotenv</code> dependency, in the <code>hardhat</code> folder run:</p>
<pre><code language="language-bash" class="language-bash">yarn add -D dotenv 
</code></pre>
<p>Then add the import on top of your Hardhat config file:</p>
<pre><code language="language-javascript" class="language-javascript">require(&#39;dotenv&#39;).config();
</code></pre>
<p>Finally, run:</p>
<pre><code language="language-bash" class="language-bash">yarn hardhat run scripts/deploy.mjs --network goerli
</code></pre>
<p>You should get something like that:</p>
<pre><code language="language-bash" class="language-bash">Contract deployed to: 0x30382c5d151FFE1837c6BB0a1fdFaBc07FD0b67A
Minted NFT #1
</code></pre>
<p>Awesome you have deployed your first smart contract in the real world! And mint an NFT.</p>
<p>Now, head to https://testnets.opensea.io/. Create this URL: https://testnets.opensea.io/assets/goerli/INSERT_DEPLOY_CONTRACT_ADDRESS_HERE/TOKEN_ID</p>
<p>Mine is: https://testnets.opensea.io/assets/goerli/0x30382c5d151FFE1837c6BB0a1fdFaBc07FD0b67A/0 (id start at 0!)</p>
<p>And you should see your first duck NFT üéâ</p>
<p>Opensea can take up to 15min to refresh so don&#39;t worry if you didn&#39;t see your NFT right away.</p>
<p>It&#39;s EPIC, but kinda boring it&#39;s the same SVG. Let&#39;s interact with it and create our duck!</p>


      </google-codelab-step>
    
      <google-codelab-step label="Frontend setup ‚öôÔ∏è" duration="5">
        <p>Ok, we worked on a smart contract. It&#39;s a lot of fun, but we have only a part of the job. What is the point of having a smart contract if nobody used it, right?</p>
<p>That&#39;s why we are now building a frontend. Not all the frontend, since we just want to build a web3 integration on top of the <a href="https://pimpmyduck.zenika.com/" target="_blank">existing CrytoDuck made but our Zenika Teammate</a>.</p>
<p>The frontend is made in React, but don&#39;t worry if you don&#39;t know. We built for you the base components, you will just fill them. By doing that, we can focus on what really matters here: interacting with the blockchain ‚õì</p>
<p>As we saw in the introduction, we will work on <code>app</code> package.</p>
<p>First, let&#39;s start the front with <code>yarn start</code>. The interface should open on <code>http://localhost:3000/</code>, and you already have a functional application to customize a duck, how cool is that?</p>
<p>What we want to do in this interface is:</p>
<ul>
<li>Connect our wallet to be able to interact with the wallet,</li>
<li>Add a <code>mint</code> button to let the user create an NFT from his custom duck.</li>
</ul>
<p>To interact with the blockchain, we need a few additional dependencies, let&#39;s install them, and then build some great stuff ‚ú®</p>
<p>In the <code>app</code> folder, do the following command:</p>
<pre><code language="language-sh" class="language-sh">yarn add @web3-react/core @web3-react/injected-connector ethers @ethersproject/providers 
</code></pre>
<p>Those packages will be the tools we need to interact with the wallet, and by that, the blockchain.</p>
<p>Packages under <code>@web3-react/*</code> are bridges between react and client libraries such <code>ethers</code> (we are using) or <code>web3</code> library. It gives us friendly tools to get a reactive state in react components.</p>
<p>Now your probably want to yell at us: &#34;GIVE ME SOME CODE!&#34;. We&#39;re getting there, don&#39;t worry üòâ</p>


      </google-codelab-step>
    
      <google-codelab-step label="Configure your front to connect a Wallet üí∞" duration="25">
        <h2 is-upgraded>Context instantiation</h2>
<p>As we saw, you add some dependencies to interact with the blockchain. This dependency needs to instantiate a <code>Context</code> to share the state with the whole app. So the first modification we have to make is in the <code>App.ts</code> component.</p>
<p>First import the context <code>Provider</code> and the web3 library:</p>
<pre><code language="language-tsx" class="language-tsx">import { Web3ReactProvider } from &#39;@web3-react/core&#39;
import { Web3Provider } from &#34;@ethersproject/providers&#34;;
</code></pre>
<p>Then, wrap the whole JSX code in the <code>return</code> block by the web3 provider:</p>
<pre><code language="language-tsx" class="language-tsx">  // ...
  return (
    &lt;Web3ReactProvider getLibrary={(provider) =&gt; new Web3Provider(provider)}&gt;
      &lt;div className={styles.app}&gt;
        {/* ... */}
     &lt;/div&gt;
    &lt;/Web3ReactProvider&gt;
  )
</code></pre>
<p>Note the provider takes a property (commonly called <code>prop</code> in react) <code>getLibrary</code>.<br> It is mandatory to initiate the web3 library we want to use. This makes <code>react-web3</code> agnostic of your client library.<br> Here, we pass a function to initialize <code>Web3Provider</code> from <code>ethers</code>, the library commonly used.</p>
<p>Great! Now we are able to discuss with the wallet in our React components!</p>
<h2 is-upgraded>Connect to a wallet</h2>
<p>The next code to update will be the <code>Web3WalletConnector</code>. This component will configure and handle all the connection logic. In that, we will find:</p>
<ul>
<li>The chain configuration,</li>
<li>Displaying a connection button the user is not connected,</li>
<li>or a disconnect button for the opposite case,</li>
<li>ask the user to change his wallet network if it is connected to the wrong chain.</li>
</ul>
<p>Let&#39;s see what we have for now.</p>
<p>You can see some constants already declared: <code>AVALANCHE_TESTNET_PARAMS</code> and <code>ETHEREUM_TESTNET_PARAMS</code>. Those variables are network configuration. We&#39;ve put them for you, but know you can find them on <a href="https://chainlist.org/" target="_blank">chainlist</a>.</p>
<p>Then, we have an empty component. For now, it does not contain any logic, but some UI. Here we can start working üí™.</p>
<p>The first step here is to remove the <code>return null</code> statement. You should now see the connect button displayed on the interface.</p>
<p>We&#39;ve put a static variable <code>active</code> to <code>false</code>. We want to get this value from the wallet instead. For that, we will call the <code>useWebReact</code> hook. This hook returns an object containing an <code>active</code> property. Perfect, this is exactly what we want!</p>
<pre><code language="language-tsx" class="language-tsx">  const { active } = useWeb3React&lt;Web3Provider&gt;()
</code></pre>
<p>Ok, now we know if we are connected directly from the wallet, nice. But, as we are not connected, we want to handle the connection. For that, the goal is to fill the <code>connect</code> function.</p>
<p>From the hook, we will get additionals properties: <code>activate</code> and <code>error</code></p>
<pre><code language="language-tsx" class="language-tsx">  const { active, activate, error } = useWeb3React&lt;Web3Provider&gt;()
</code></pre>
<p>If we take a look at the activated signature, we can see it takes an argument <code>injected</code>. WTF is that?! üò±</p>
<p>It is information about the chains our application can use.</p>
<p>Chains&#39; information makes sense now!</p>
<p>We are going to declare a new variable <code>injected</code>, by instantiating a new <code>InjectedConnector</code>.<br> The constructor takes an object, with the property <code>supportedChainIds</code>.</p>
<pre><code language="language-tsx" class="language-tsx">const injected = new InjectedConnector({
  supportedChainIds: [
    parseInt(ETHEREUM_TESTNET_PARAMS.chainId, 16),
    parseInt(AVALANCHE_TESTNET_PARAMS.chainId, 16),
  ],
})
</code></pre>
<p>Because this variable is not reactive, it can be defined outside our component.</p>
<p>Now we have all our <code>activate</code> dependencies, we can call our function in <code>connect</code> function.</p>
<pre><code language="language-tsx" class="language-tsx">  async function connect() {
    await activate(injected)
  }
</code></pre>
<p>Time to test!</p>
<h2 is-upgraded>Connection testing</h2>
<p>To test a wallet connection, you need to first have a Wallet.<br> You should already have one so, let&#39;s go click our connect button.<br> You should see a pop-up asking you to approve the connection to our website. If you accept, you should then see your address instead of the login button.</p>
<p>Awesome!</p>
<p>If you wonder what&#39;s under the button, you can look for <code>Web3WalletButton</code>.<br> It calls the hook <code>useWeb3React</code>, and gets the connected address, and the active props.</p>
<p>From the <code>active</code> props, we decide what we display: a truncated address or a connection button.</p>
<p>The parent component <code>Web3WalletConnector</code> displayed an additional logout button when we are connected.</p>
<p>We still have to complete the disconnected behavior.</p>
<p>From the <code>useWeb3React</code>, get another property: <code>disconnect</code>. It is a function. Call it from the disconnect function, and we are good! Good Job! üôå</p>


      </google-codelab-step>
    
      <google-codelab-step label="Integrate and interact with your smart contract" duration="15">
        <p>For now, we implemented the connection with our wallet. That&#39;s already great, but we&#39;re here to interact with our smart contract right? Let&#39;s goooo üßë‚Äçüíª</p>
<p>The frontend, and the web3 library needs to know what is the structure of our contract. This means:</p>
<ul>
<li>the public data exposed,</li>
<li>public functions,</li>
<li>events (yeah, the Ethereum Virtual Machine aka EVM has built-in support for events)</li>
</ul>
<p>And there is a file containing all those information, produced on the smart contract build: the JSON artifact.</p>
<p>In the contract package, look for the <code>artifacts/contracts/</code> folder. Find the file with the name of our contract, and take a look at the content.</p>
<p>It contains all the information our frontend needs. üéâ</p>
<p>OK, now we know what we have, let&#39;s think about what we want.</p>
<p>The goal will be to actually mint our NFT, finally!<br> To achieve that, we want to call our smart contract function <code>makeAnEpicNFT</code>, and listen to the event <code>NewNFTMinted</code>.<br> From the event, we will get the token id, and display an URL to be able to see it.</p>
<p>We have created for you the <code>Mint</code> component containing the structure so we can focus on the business logic. Take a look at this component.</p>
<p>We have two functions to fill: <code>setupEventListener</code> and <code>askContractToMintNft</code>.<br> The first one will listen to the mint event on our contract, and the second will call our contract to mint the NFT.</p>
<p>The component return <code>null</code> if <code>active</code> is <code>false</code>, and a button otherwise.<br> This means if you are connected, the button should appear.</p>
<p>Let&#39;s go!</p>
<p>The first thing is to replace the <code>active</code> variable to get it from the <code>useWeb3React</code> hook.<br> We already did it, so it should be easy üòõ</p>
<p>Take also the <code>library</code> property from the hook, we will need it. It&#39;s better to give <code>Web3Provider</code> as a generic parameter to the hook. It will type the <code>library</code> property for us.</p>
<p>We take <code>library</code> here because we need it to call the blockchain.</p>
<p>Let&#39;s code the event listener. It&#39;s the &#34;easier&#34; part, and we will be able to understand the basics.</p>
<h2 is-upgraded>Event Listener</h2>
<p>First, the variable <code>provider</code> can be <code>undefined</code>, so we need to verify it isn&#39;t.</p>
<pre><code language="language-ts" class="language-ts">  const setupEventListener = useCallback(() =&gt; {
    if (!library) {
      return
    }
  }
</code></pre>
<p>Then, because of the inherited behavior of <code>ethers</code> library, we need to get the transaction <code>signer</code>.</p>
<pre><code language="language-tsx" class="language-tsx">    const signer = library.getSigner()
</code></pre>
<p>Secondly, we will create a contract client instance.</p>
<pre><code language="language-ts" class="language-ts">    const connectedContract = new Contract(
      // ...
    )
</code></pre>
<p>This constructor takes 3 arguments:</p>
<ul>
<li>The contract address,</li>
<li>The contract ABI (Application Binary Interface). It is a sub-part of the JSON artifact we talked about before,</li>
<li>The <code>signer</code> variable we created before. It will be used to sign transactions.</li>
</ul>
<p>Let&#39;s fill them in one by one.</p>
<p>On the top of the file, we&#39;ve created a <code>CONTRACT_ADDRESS</code> constant to replace. Put here the contract address you got when you deployed your contract.</p>
<p>For the ABI, it should be on the contract package. Let&#39;s copy the <code>MyEpicSmartContract.json</code> in the <code>src</code> folder, and then import it.</p>
<pre><code language="language-bash" class="language-bash"># this assume your shell location is in the root folder
cp packages/hardhat/artifacts/contracts/MyEpicSmartContract.sol/MyEpicSmartContract.json packages/app/src 
</code></pre>
<pre><code language="language-tsx" class="language-tsx">import myEpicNft from &#39;../MyEpicSmartContract.json&#39;
</code></pre>
<p>And for the signers, we&#39;ve created a variable for it, perfect!</p>
<p>We should have this:</p>
<pre><code language="language-tsx" class="language-tsx">    const signer = library.getSigner()
    const contract = new Contract(
      CONTRACT_ADDRESS,
      myEpicNft.abi,
      signer
    )
</code></pre>
<p>Now we have a contract client instance, we can interact with our contract!<br> To listen to events, we need to call the <code>on</code> method and pass it our event name <code>NewNFTMinted</code> as the first parameter, and a callback as the second parameter.<br> The first argument of the callback is the contract address, and the second is the return type of the method called (here the token id is a big number).</p>
<p>‚ÑπÔ∏è to get the number of our token from a BigNumber, we need to call <code>toNumber</code> method on it.</p>
<p>Our UI will be simple. We will display an alert with the received information.</p>
<pre><code language="language-tsx" class="language-tsx">    contract.on(&#39;NewNFTMinted&#39;, (from, tokenId) =&gt; {
      console.log(from, tokenId.toNumber())
      alert(
        `Hey there! We&#39;ve minted your NFT and sent it to your wallet. It may be blank right now. It can take a max of 10 min to show up on OpenSea. Here&#39;s the link: https://testnets.opensea.io/assets/${CONTRACT_ADDRESS}/${tokenId.toNumber()}`
      )
    })
</code></pre>
<p>‚ÑπÔ∏è The <code>ethers</code> library used under the hood is not perfect here, and we loose our strong typing üò≠</p>
<p>Finally, add <code>library</code> in the dependency array of <code>useCallback</code>. This tells to react to recompute the function if the <code>library</code> changes.</p>
<p>üôå We have a listener set up! üôå But we can&#39;t test it without minting an NFT, so let&#39;s do that!</p>
<h2 is-upgraded>LET&#39;S MINT</h2>
<p>Here we go! The final part!</p>
<p>Here we will fill in the <code>askContractToMintNft</code> function. But this one has a bit much logic to handle.</p>
<p>When the user will click on the button, it will fire our function.<br> Our component only has an SVG HTML element reference. But we want our NFT to have an actual image!<br> So the first step will be to create an image from the element we have.</p>
<p>Then, we have to store it. But on the blockchain, we pay for every storage we use, and we don&#39;t want the mint to be overly expensive!</p>
<p>Here, we have 2 solutions.<br> The first one: store our image in a traditional manner. Like an S3 bucket. But we want to create a decentralized application! What happens to our NFT if the S3 is deleted? We have only data, but no image attached to it. We will have a broken NFT. The second one: store it on IPFS, a decentralized storage. It seems a lot better, right? üòÅ But IPFS has some issues too. It&#39;s a protocol, which means the user will have to install the protocol on his computer to interact with or use a gateway. Which is centralized üòÖ</p>
<p>Here, we will use a gateway deployed on AWS. Some libraries allow us to run a minimal IPFS node in Javascript in the browser. It would be a better solution since doing that we don&#39;t have a single point of failure. Never mind, for our little project the gateway solution was fun!</p>
<p>Enough talk, let&#39;s code!</p>
<p>First, we will inform the UI we&#39;re doing some stuff and it needs to display a loader.<br> We&#39;ve received a <code>setIsLoading</code> method from props, so let&#39;s call it.</p>
<pre><code language="language-tsx" class="language-tsx">    setIsLoading(true)
</code></pre>
<p>Then, we will verify we do have an SVG element or throw an error otherwise.</p>
<pre><code language="language-tsx" class="language-tsx">    if (!svgRef.current) {
      throw new Error(&#39;No SVG&#39;)
    }
</code></pre>
<p>Now we&#39;re sure we have an SVG element, let&#39;s create an image from it.<br> Thankfully, we&#39;ve created a <code>getSvgImageFromSvgElement</code> function for you ü´°</p>
<pre><code language="language-tsx" class="language-tsx">    const svg = await getSvgImageFromSvgElement(svgRef.current)
</code></pre>
<p>And let&#39;s upload it to IPFS. Here too, you have a <code>uploadToIPFS</code> function to make your life easier ü´° This function takes an object parameter with 2 properties: <code>svg</code> and <code>name</code></p>
<pre><code language="language-tsx" class="language-tsx">    const cid = await uploadSvgToIPFS({
      svg,
      name: `nft ${new Date().toISOString()}`,
    })
</code></pre>
<p>Now we have a unique identifier for our stored image. Exactly what our contract needs üòÅ</p>
<p>We can call our contract. Remember the &#34;get the signer&#34;, &#34;create a contract instance&#34; stuff?<br> We will repeat it here.</p>
<ul>
<li>&#34;Gnagnagna that&#39;s a code duplication&#34; YES IT IS! Two time duplication is ok, if this code was repeated 3,4,5 times, we would have created an abstraction.</li>
</ul>
<pre><code language="language-tsx" class="language-tsx">    const signer = library.getSigner()
    const connectedContract = new ethers.Contract(
      CONTRACT_ADDRESS,
      myEpicNft.abi,
      signer
    )
</code></pre>
<p>Nooooooow, we can create a transaction üî•</p>
<p>Before we was listening to an event, so we called <code>on</code> the method. Here to call a distributed method, we can directly call the method on the contract instance.</p>
<p>If your IDE does not autocomplete, it&#39;s normal, the contract does not infer our ABI, and it&#39;s really sad üò≠.</p>
<pre><code language="language-tsx" class="language-tsx">    const nftTxn = await connectedContract.makeAnEpicNFT(`ipfs://${cid}`)
</code></pre>
<p>Then we will wait for the transaction to be processed</p>
<pre><code language="language-tsx" class="language-tsx">    await nftTxn.wait()
</code></pre>
<p>And inform the UI we have FINISHED üéâ</p>
<pre><code language="language-tsx" class="language-tsx">    setIsLoading(false)
</code></pre>
<p>TIME TO TEST!</p>


      </google-codelab-step>
    
      <google-codelab-step label="Bonus" duration="15">
        <p>As a bonus, you can update the smart-contract to add new features.<br> Feel free to invent one! Distributed technologies offer endless possibilities!</p>
<p>Here are some ideas:</p>
<ul>
<li>Restrict the mint to one NFT per user,</li>
<li>Limit the total amount of ducks possibles (rarity),</li>
<li>Store duck properties<br> This will allow other possibilities: <ul>
<li>Have some inheritance, a duck could inherit some properties of his parent,</li>
<li>Turn them into fighting ducks with combat properties,</li>
<li>etc...</li>
</ul>
</li>
</ul>
<p>We&#39;re not guiding you for the bonus, but feel free to reach out for help ü§úü§õ</p>
<p>And at the end, tell us what you&#39;ve made ü´∂.</p>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
  <script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/claat-public/prettify.js"></script>
  <script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
