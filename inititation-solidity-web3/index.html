
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Initiation solidity and Web3.0</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid="Google Analytics ID"
                  id="inititation-solidity-web3"
                  title="Initiation solidity and Web3.0"
                  environment="web"
                  feedback-link="https://github.com/Gosunet/workshop-initiation-solidity-web3">
    
      <google-codelab-step label="Init your project ðŸ”¨" duration="5">
        <p>If you have not done it yet, you can start by cloning this repo</p>
<pre><code language="language-sh" class="language-sh">git clone https://github.com/Gosunet/workshop-initiation-solidity-web3.git
</code></pre>
<p>If we take a look at the structure, we can notice it&#39;s a monorepo using yarn workspaces.</p>
<p>At the root, you can see a folder name <code>packages</code>. In this folder we have separated packages.</p>
<p>We will focus on two packages today: <code>app</code> and <code>hardhat</code>.</p>
<p>The first contains our frontend, and the second will contains our contract.</p>
<p>Now we&#39;ve seen that, let&#39;s start building! ðŸš€</p>
<h2 is-upgraded>Setup Hardhat</h2>
<p><a href="https://hardhat.org/hardhat-runner/docs/getting-started#quick-start" target="_blank">Hardhat</a> is a framework that will help us to:</p>
<ul>
<li>compile our smart contract</li>
<li>test our smart contract</li>
<li>deploy our smart contract</li>
</ul>
<p>If you feel adventurous you can alternatively use <a href="https://trufflesuite.com/docs/" target="_blank">Truffle</a> or <a href="https://github.com/foundry-rs/foundry" target="_blank">Fundry</a>. Both are pretty similar to Hardhat in term of features.</p>
<p>Install Hardhat</p>
<pre><code language="language-sh" class="language-sh">yarn workspace src add -D hardhat
</code></pre>
<p>if you need to install yarn before <code>npm install --global yarn</code></p>
<p>Then init hardhat in your <code>package/src</code> folder</p>
<pre><code language="language-sh" class="language-sh">yarn hardhat
</code></pre>
<p>This will create folders :</p>
<ul>
<li><code>contracts</code> : folder for our solidity files,</li>
<li><code>scripts</code> : a directory that contain scripts to handle deploy, run, ...</li>
<li><code>test</code>: unit test sources,</li>
<li><code>hardhat-config.js</code> : config file for Hardhat</li>
</ul>
<p>Finally, run <code>yarn hardhat node</code> and this should print out a bunch of accounts.</p>
<p>Hardhat will generate some files for you, to make sure everything is working, run:</p>
<pre><code language="language-sh" class="language-sh"> yarn hardhat compile
</code></pre>
<p>Then run:</p>
<pre><code language="language-sh" class="language-sh"> yarn hardhat test
</code></pre>
<p>You should see a bunch of tests succeeded ðŸŽ‰</p>
<p>You can now delete Lock.js under test, deploy.js under scripts and Lock.sol under contracts. (not the folder!)</p>


      </google-codelab-step>
    
      <google-codelab-step label="Write your first smart contract ðŸ†•" duration="20">
        <p>Now that we have setup Hardhat let&#39;s create our first smart contract!<br> To do so let&#39;s create a new file <code>MyEpicSmartContract.sol</code> under <code>contracts</code> folder.<br> Be careful file structure is important!</p>
<p>Copy this into your newly created file</p>
<pre><code language="language-javascript" class="language-javascript">// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.17;

import &#34;hardhat/console.sol&#34;;

contract MyEpicSmartContract {
    constructor() {
        console.log(&#34;Hello World !&#34;);
    }
}
</code></pre>
<p>If you use visual code you can install the <a href="https://marketplace.visualstudio.com/items?itemName=JuanBlanco.solidity&utm_source=buildspace.so&utm_medium=buildspace_project" target="_blank">solidity extension</a> for syntax highlighting.</p>
<p>Congratulation you have officialy write your first smart contract ðŸ¥³<br> Easy no?</p>
<p>Next step is to compile our smart contract, to do so run <code>yarn hardhat compile</code>.</p>
<p>Now it&#39;s our turn to work!<br> Let&#39;s create a small function to set an attribute <code>name</code> into our smart contract. Then another function <code>sayHello</code> that will simply use the name you just set and print <code>Hello ${name}</code> in console.<br> Here is a link to the <a href="https://docs.soliditylang.org/en/v0.8.12/introduction-to-smart-contracts.html" target="_blank">solidity doc</a> to help you with that.</p>
<h2 is-upgraded>A script to run our contract</h2>
<p>Hardhat allow us to deploy our smart contract in a local blockchain, and it allow us to do it very easily.</p>
<p>We juste have to write a small script to do that, so let&#39;s go!</p>
<p>Create a file <code>run.mjs</code> under <code>scripts</code>.</p>
<pre><code language="language-javascript" class="language-javascript">const contractFactory = await hre.ethers.getContractFactory(&#39;MyEpicSmartContract&#39;);
const contract = await contractFactory.deploy();
await contract.deployed();
console.log(&#34;Contract deployed to:&#34;, contract.address);

// Call the function.
let txn = await contract.setName(&#34;Guillaume&#34;)
// Wait for it to be finished.
await txn.wait()
// Call another function
await contract.sayHello()
</code></pre>
<p>To call your script just run <code>yarn hardhat run scripts/run.mjs</code>.</p>
<p>You should get something like that!</p>
<pre><code language="language-bash" class="language-bash">Hello World !
Contract deployed to: 0x5FbDB2315678afecb367f032d93F642f64180aa3
Hello Guillaume
</code></pre>
<p><code>0x5FbDB2315678afecb367f032d93F642f64180aa3</code> here is the contract adresse in our local blockchain where the contract was deployed.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Create a contract that mints NFTs ðŸ¦†" duration="20">
        <p>It&#39;s all fun and stuff but our contract is not doing anything usefull for our use case.</p>
<p>Let&#39;s change that! What we want is a contract that enable us to <code>mint</code> an NFT. Mint just mean to create our NFT in the blockchain.</p>
<p>But what&#39;s an NFT ? On the EVM compatible blockchain an NFT is &#34;just&#34; an <a href="https://ethereum.org/en/developers/docs/standards/tokens/erc-721/" target="_blank">ERC-721 token</a>, that mean that our smart contract should implement the ERC-721 interface!</p>
<p>That&#39;s a lot of work. Fortunatly for us in Solidity we can use inherance and there are open-source contract available that we can inherit from to do that! <a href="https://github.com/OpenZeppelin" target="_blank">OpenZeppelin</a> is probably the most know for that, is popular, used by a lot a people, and secure (at least it as been audited strongly and used in the real world without flaws).</p>
<p>We first need to add the openzeppelin dependency.</p>
<pre><code language="language-bash" class="language-bash">yarn add @openzeppelin/contracts
</code></pre>
<p>Then import them in our contract like that</p>
<pre><code language="language-javascript" class="language-javascript">import &#34;@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol&#34;;
import &#34;@openzeppelin/contracts/utils/Counters.sol&#34;;
</code></pre>
<p>As you can see we also import <code>Counters.sol</code>, this will help us to generate our NFT id.</p>
<p>Now that we have imported the contract <code>ERC721URIStorage</code> what we need to do now is to make our contract inherit from it.</p>
<p>To do that it&#39;s pretty simple !</p>
<pre><code language="language-javascript" class="language-javascript">// We inherit the contract we imported. This means we&#39;ll have access
// to the inherited contract&#39;s methods.
contract MyEpicSmartContract is ERC721URIStorage {

  // We need to pass the name of our NFTs token and it&#39;s symbol.
  constructor() ERC721 (&#34;CryptoDuck&#34;, &#34;DUCK&#34;) {
    console.log(&#34;This is my NFT contract. Woah!&#34;);
  }
</code></pre>
<p>You will see that here we need to call the <code>ERC721</code> contract constructor with two string, one for the name of our NFT token, and the other one for the symbol of our collection.</p>
<p>Feel free to name it as you want ðŸ˜‰</p>
<p>Now we can use the <code>ERC721</code> contract method !<br> Let&#39;s create our mehtode that we will call to create our NFT that will represente our custom duck.<br> We don&#39;t want to store the whole duck SVG in our contract because storage in the blockchain cost money ðŸ’° so we will only store the url to access to our duck SVG.</p>
<p>Remember that data in the blockchain are immutable, this is why it&#39;s important that our url will be accessible FOREVER ! That&#39;s why it&#39;s strongly recommended to stare our image in a decentralized store file systeme like IPFS.</p>
<pre><code language="language-javascript" class="language-javascript">function makeAnEpicNFT(string memory srcTokenUri) public { 

}
</code></pre>
<p>Each of our NFT will need an unique ID to do that we will use the <code>Counters.sol</code> we have imported.</p>
<p>Add this in your contract</p>
<pre><code language="language-javascript" class="language-javascript">using Counters for Counters.Counter;
Counters.Counter private _tokenIds;
</code></pre>
<p>Let&#39;s code our contract to mint an NFT now !</p>
<p>First we want to get the currrent ID for your new NFT</p>
<pre><code language="language-javascript" class="language-javascript">uint256 newItemId = _tokenIds.current();
</code></pre>
<p>Then we will mint our NFT calling the methode from the OpenZeppelin contract (all internal methode are prefix with an undescrore)</p>
<pre><code language="language-javascript" class="language-javascript">_safeMint(msg.sender, newItemId);
</code></pre>
<p>Notice <code>msg.sender</code> here, it&#39;s a magic solidity variable that hold the address of the wallet that call this methode.</p>
<p>We want our NFT to avec an image, to do that we will create a <code>payload</code> that respect some convention used to parse NFT, doing that our NFT will be readable in marketplace like <a href="https://opensea.io/" target="_blank">OpenSea</a>. We also want our payload to be as tiny as possible, that&#39;s why we will encode it in base64.</p>
<pre><code language="language-javascript" class="language-javascript">// Get all the JSON metadata in place and base64 encode it.
string memory json = Base64.encode(
    bytes(
        string(
            abi.encodePacked(
                &#39;{&#34;name&#34;: &#34;Crypto Duck&#34;, &#34;description&#34;: &#34;A magnificent crypto duck.&#34;, &#34;image&#34;: &#34;&#39;, srcTokenUri, &#39;&#34;}&#39;
            )
        )
    )
);

// Just like before, we prepend data:application/json;base64, to our data.
string memory finalTokenUri = string(
    abi.encodePacked(&#34;data:application/json;base64,&#34;, json)
);
</code></pre>
<p>Feel free again to change the name or description of our Duck. Maybe you can have an dynamic name and description ? Use a name set in the front end ?</p>
<p>Finally we need to set the date to the NFT</p>
<pre><code language="language-javascript" class="language-javascript">// Set the NFTs data.
_setTokenURI(newItemId, finalTokenUri);

console.log(&#34;An NFT w/ ID %s has been minted to %s&#34;, newItemId, msg.sender);
</code></pre>
<p>And increment the counter</p>
<pre><code language="language-javascript" class="language-javascript">// Increment the counter for when the next NFT is minted.
_tokenIds.increment();
</code></pre>
<p>One thing that we can do is to emit an Event, the front will be able to listen to that Event and show some stuff to the user.</p>
<p>To do that declare a new Event in our contract</p>
<pre><code language="language-javascript" class="language-javascript">event NewNFTMinted(address sender, uint256 tokenId);
</code></pre>
<p>and emit it at the end of your <code>makeAnEpicNFT</code> methode.</p>
<pre><code language="language-javascript" class="language-javascript">emit NewNFTMinted(msg.sender, newItemId);
</code></pre>
<p>At the end you should get something like that</p>
<pre><code language="language-javascript" class="language-javascript">function makeAnEpicNFT(string memory srcTokenUri) public {
    require(balanceOf(msg.sender) == 0, &#39;Each address may only own one crypto duck&#39;);
    // Get the current tokenId, this starts at 0.
    uint256 newItemId = _tokenIds.current();

     // Actually mint the NFT to the sender using msg.sender.
    _safeMint(msg.sender, newItemId);

    // Get all the JSON metadata in place and base64 encode it.
    string memory json = Base64.encode(
        bytes(
            string(
                abi.encodePacked(
                    &#39;{&#34;name&#34;: &#34;Crypto Duck&#34;, &#34;description&#34;: &#34;A magnificent crypto duck.&#34;, &#34;image&#34;: &#34;&#39;, srcTokenUri, &#39;&#34;}&#39;
                )
            )
        )
    );

    // Just like before, we prepend data:application/json;base64, to our data.
    string memory finalTokenUri = string(
        abi.encodePacked(&#34;data:application/json;base64,&#34;, json)
    );

    // Set the NFTs data.
    _setTokenURI(newItemId, finalTokenUri);

    console.log(&#34;An NFT w/ ID %s has been minted to %s&#34;, newItemId, msg.sender);

    // Increment the counter for when the next NFT is minted.
    _tokenIds.increment();

    emit NewNFTMinted(msg.sender, newItemId);
  }
</code></pre>
<p>That&#39;s cool and stuff but how can I test my code ? Let&#39;s see that in the next chapter !</p>


      </google-codelab-step>
    
      <google-codelab-step label="Test it !" duration="20">
        

      </google-codelab-step>
    
      <google-codelab-step label="Deploy your smart contract ðŸš€" duration="20">
        <h2 is-upgraded>Get a Wallet ! And some ETH ðŸ’°</h2>
<h2 is-upgraded>Deploy</h2>


      </google-codelab-step>
    
      <google-codelab-step label="Frontend setup âš™ï¸" duration="5">
        <p>Ok, we worked on a smart contract. It&#39;s a lot of fun, but we have only a part of the job. What is the point of having a smart contract if nobody use it, right?</p>
<p>That&#39;s why we are now building a frontend. Not all the frontend, since we just want to build a web3 integration on top of the <a href="https://pimpmyduck.zenika.com/" target="_blank">existing CrytoDuck made but our Zenika Teammate</a>.</p>
<p>The frontend is made in React, but don&#39;t worry if you don&#39;t know. We built for you the base components, you will just filled them. Doing that, we can focus on what really matter here: interacting with the blockchain â›“</p>
<p>As we seen in introduction, we will work on <code>app</code> package.</p>
<p>First, let&#39;s start the front with <code>yarn start</code>. The interface should open on <code>http://localhost:3000/</code>, and you already have an functional application to customize a duck, how cool is that?</p>
<p>What we want to do in this interface is:</p>
<ul>
<li>Connect our wallet to be able to interact with the wallet,</li>
<li>Add a <code>mint</code> button to let the user create an NFT from his custom duck.</li>
</ul>
<p>To interact with the blockchain, we need few additional dependencies, let&#39;s install them, and them build some great stuff âœ¨</p>
<p>In the <code>app</code> folder, do the following command:</p>
<pre><code language="language-sh" class="language-sh">yarn add @web3-react/core @web3-react/injected-connector web3 
</code></pre>
<p>Those packages will be the tools we need to interact with the wallet, and by that, the blockchain.</p>
<p>Packages under <code>@web3-react/*</code> are abstractions on top of the <code>web3</code> library. It give us friendly tools to get a reactive state in react components.</p>
<p>Now your probably want to yell at us: &#34;GIVE ME SOME CODE!&#34;. We&#39;re getting there, don&#39;t worry ðŸ˜‰</p>


      </google-codelab-step>
    
      <google-codelab-step label="Configure your front to connect a Wallet ðŸ’°" duration="25">
        <h2 is-upgraded>Context instantiation</h2>
<p>As we saw, you add some dependencies to interact with the blockchain. This dependency needs to instantiate a <code>Context</code> to share the state with the whole app. So the first modification we have to make is in the <code>App.ts</code> component.</p>
<p>First import the context <code>Provider</code> and the web3 library:</p>
<pre><code language="language-tsx" class="language-tsx">import { Web3ReactProvider } from &#39;@web3-react/core&#39;
import Web3 from &#39;web3&#39;
</code></pre>
<p>Then, wrap the whole JSX code in the <code>return</code> block by the web3 provider:</p>
<pre><code language="language-tsx" class="language-tsx">  // ...
  return (
    &lt;Web3ReactProvider getLibrary={(provider) =&gt; new Web3(provider)}&gt;
      &lt;div className={styles.app}&gt;
        {/* ... */}
     &lt;/div&gt;
    &lt;/Web3ReactProvider&gt;
  )
</code></pre>
<p>Note the provider take a property (commonly called <code>prop</code> in react) <code>getLibrary</code>.<br> It is mandatory to initiate the web3 library we want to use. This make <code>react-web3</code> agnostic of your client library.<br> Here, we pass a function to initialize <code>Web3</code>, the library commonly used.</p>
<p>Great! Now we are able to discuss with the wallet in our React components!</p>
<h2 is-upgraded>Connect to a wallet</h2>
<p>The next code to update will be the <code>Web3WalletConnector</code>. This component will configure handle all the connection logic. In that, we will find:</p>
<ul>
<li>The chain configuration,</li>
<li>Displaying a connection button the user is not connected,</li>
<li>or a disconnect button for the opposite case,</li>
<li>ask the user to change his wallet network if it is connected to the wrong chain.</li>
</ul>
<p>Let&#39;s see what we have for now.</p>
<p>You can see some constants already declared: <code>AVALANCHE_TESTNET_PARAMS</code> and <code>ETHEREUM_TESTNET_PARAMS</code>. Those variable are network configuration. We&#39;ve put them for you, but know you can find them on <a href="https://chainlist.org/" target="_blank">chainlist</a>.</p>
<p>Then, we have a empty component. For now, it does not contain any logic, but some UI. Here we can start working ðŸ’ª.</p>
<p>The fist step here is to remove the <code>return null</code> statement. You should now see the connect button display on the interface.</p>
<p>We&#39;ve put a static variable <code>active</code> to <code>false</code>. We want to get this value from the wallet instead. For that, we will call the <code>useWebReact</code> hook. This hook return an object containing an <code>active</code> property. Perfect, this is exactly what we want!</p>
<pre><code language="language-tsx" class="language-tsx">  const { active } = useWeb3React&lt;Web3&gt;()
</code></pre>
<p>Ok, now we know if we are connected directly from the wallet, nice. But, as we are not connected, we want to handle the connection. For that, the goal is to fill the <code>connect</code> function.</p>
<p>From the hook, we will get an additional property: <code>activate</code></p>
<pre><code language="language-tsx" class="language-tsx">  const { active, activate } = useWeb3React&lt;Web3&gt;()
</code></pre>
<p>If we take a look at the activate signature, we can see it takes an argument <code>injected</code>. WTF is that?! ðŸ˜±</p>
<p>It is informations about the chains our application is able to use. Chains informations make sense now!</p>
<p>We are going to declare a new variable <code>injected</code>, by instantiating a new <code>InjectedConnector</code>.<br> The constructor take an object, with the property <code>supportedChainIds</code>.</p>
<pre><code language="language-tsx" class="language-tsx">const injected = new InjectedConnector({
  supportedChainIds: [
    parseInt(ETHEREUM_TESTNET_PARAMS.chainId, 16),
    parseInt(AVALANCHE_TESTNET_PARAMS.chainId, 16),
  ],
})
</code></pre>
<p>Because this variable is not reactive, it can be defined outside our component.</p>
<p>Now we have all our <code>activate</code> dependencies, we can call our function in <code>connect</code> function.</p>
<pre><code language="language-tsx" class="language-tsx">  async function connect() {
    await activate(injected)
  }
</code></pre>
<p>Time to test!</p>
<h2 is-upgraded>Connection testing</h2>
<p>To test a wallet connection, you need to first have a Wallet.<br> So if you don&#39;t already have on, download the <a href="https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn?hl=fr" target="_blank">metamask extension on chrome web store</a>.</p>
<p>You will be guided on the setup phase by Metamask. When this part is done, switch to Goerly network. It is a testing network.</p>
<p>Now you&#39;re all set, let&#39;s go clicking our connect button. You should see a pop-up asking you to approve the connection to our website. If you accept, you should then see your address instead of the login button.</p>
<p>Awesome!</p>
<p>If you wonder what&#39;s under the button, you can look for <code>Web3WalletButton</code>.<br> It calls the hook <code>useWeb3React</code>, and get the connected address, and the active props.</p>
<p>From the <code>active</code> props, we decide what we display: a truncated address or a connection button.</p>
<p>The parent component <code>Web3WalletConnector</code> display an additional logout button when we are connected.</p>
<p>We still have to complete the disconnect behavior.</p>
<p>From the <code>useWeb3React</code>, get an other property: <code>disconnect</code>. It is a function. Call it from the disconnect function, and we are good! Good Job! ðŸ™Œ</p>


      </google-codelab-step>
    
      <google-codelab-step label="Integrate and interact with your smart contract" duration="15">
        

      </google-codelab-step>
    
      <google-codelab-step label="Bonus" duration="15">
        

      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
